import cv2
import numpy as np

# skeletonizes image
def skeletonize(img):
    skeleton = np.zeros_like(img)
    img = img / 255
    kernel = np.array([[0, 0, 0],
                       [1, 1, 1],
                       [0, 0, 0]], dtype=np.uint8)
    
    #instead we can implement the kernel function we already have and the 
    while True:
        eroded = cv2.erode(img, kernel)
        temp = cv2.dilate(eroded, kernel)
        temp  = img - temp
        skeleton |= temp
        img = eroded.copy()
        if np.sum(img) == 0:
            break
    return skeleton.astype(np.uint8) * 255

image = cv2.imread("/Users/madisondetrick/Documents/VisualStudios/deep_layer.jpg", cv2.IMREAD_GRAYSCALE)





def find_centerline():
    _, binary = cv2.threshold(image, 127, 255, cv2.THRESH_BINARY)
    skeleton = skeletonize(binary)
    contours, _ = cv2.findContours(skeleton, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    contours = sorted(contours, key=cv2.contourArea, reverse=True)
    largest_contour = contours[0]

    vx, vy, x, y = cv2.fitLine(largest_contour, cv2.DIST_L2, 0, 0.01, 0.01)

    lefty = int((-x * vy / vx) + y)
    righty = int(((image.shape[1] - x) * vy / vx) + y)
    centerline_image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)
    cv2.line(centerline_image, (0, lefty), (image.shape[1] - 1, righty), (0, 255, 0), 2)
    output_file = 'centerline_result.png'
    cv2.imwrite(output_file, centerline_image)
    print(f"Result saved to {output_file}")

# Optionally, display the result


find_centerline()

cv2.waitKey(0)
cv2.destroyAllWindows()
